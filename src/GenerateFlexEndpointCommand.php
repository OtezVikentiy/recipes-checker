<?php

/*
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace App;

use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\HttpClient\HttpClient;

#[AsCommand(name: 'generate:flex-endpoint', description: 'Generates the json files required by Flex')]
class GenerateFlexEndpointCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->addArgument('repository', InputArgument::REQUIRED, 'The name of the GitHub repository')
            ->addArgument('source_branch', InputArgument::REQUIRED, 'The source branch of recipes')
            ->addArgument('flex_branch', InputArgument::REQUIRED, 'The branch of the target Flex endpoint')
            ->addArgument('output_directory', InputArgument::REQUIRED, 'The directory where generated files should be stored')
            ->addOption('contrib')
        ;
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $repository = $input->getArgument('repository');
        $sourceBranch = $input->getArgument('source_branch');
        $flexBranch = $input->getArgument('flex_branch');
        $outputDir = $input->getArgument('output_directory');
        $contrib = $input->getOption('contrib');

        $aliases = $recipes = [];

        // stdin usually generated by `git ls-tree HEAD */*/*`

        while (false !== $line = fgets(STDIN)) {
            [$tree, $package] = explode("\t", trim($line));
            [,, $tree] = explode(' ', $tree);

            if (!file_exists($package.'/manifest.json')) {
                continue;
            }

            $manifest = json_decode(file_get_contents($package.'/manifest.json'), true);
            $version = substr($package, 1 + strrpos($package, '/'));
            $package = substr($package, 0, -1 - \strlen($version));

            $this->generatePackageJson($repository, $sourceBranch, $contrib, $package, $version, $manifest, $tree, $outputDir);

            foreach ($manifest['aliases'] ?? [] as $alias) {
                $aliases[$alias] = $package;
                $aliases[str_replace('-', '', $alias)] = $package;
            }

            if (0 === strpos($package, 'symfony/') && '-pack' !== substr($package, -5)) {
                $alias = substr($package, 8);
                $aliases[$alias] = $package;
                $aliases[str_replace('-', '', $alias)] = $package;
            }

            $recipes[$package][] = $version;
            usort($recipes[$package], 'strnatcmp');
        }

        uksort($aliases, 'strnatcmp');
        uksort($recipes, 'strnatcmp');

        file_put_contents($outputDir.'/index.json', json_encode([
            'aliases' => $aliases,
            'recipes' => $recipes,
            'versions' => $contrib ? [] : HttpClient::create()->request('GET', 'https://flex.symfony.com/versions.json')->toArray(),
            'git_url' => sprintf('https://github.com/%s.git', $repository),
            'tree_template' => sprintf('https://github.com/%s/tree/{tree}/{package}/{version}', $repository),
            'recipe_template' => sprintf('https://raw.githubusercontent.com/%s/%s/{package_dotted}.{version}.json', $repository, $flexBranch),
            'is_contrib' => $contrib,
        ], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));

        return 0;
    }

    private function generatePackageJson(string $repository, string $sourceBranch, bool $contrib, string $package, string $version, array $manifest, string $tree, string $outputDir)
    {
        $files = [];
        $it = new \RecursiveDirectoryIterator($package.'/'.$version);
        $it->setFlags($it::SKIP_DOTS | $it::FOLLOW_SYMLINKS);

        foreach (new \RecursiveIteratorIterator($it) as $path => $file) {
            $file = substr($path, 1 + \strlen($package.'/'.$version));
            if (is_dir($path) || \in_array($file, ['manifest.json', 'post-install.txt', 'Makefile'], true)) {
                continue;
            }
            $contents = file_get_contents($path);
            $isUtf8 = preg_match('//u', $contents);
            $files[$file] = [
                'contents' => $isUtf8 ? $contents : base64_encode($contents),
                'executable' => is_executable($path),
                'encoding' => $isUtf8 ? '' : 'base64',
            ];
        }

        file_put_contents(sprintf('%s/%s.%s.json', $outputDir, str_replace('/', '.', $package), $version), json_encode([
            'locks' => [
                $package => [
                    'version' => $version,
                    'recipe' => [
                        'repo' => $version,
                        'branch' => $sourceBranch,
                        'version' => $version,
                        'ref' => $tree,
                    ],
                ],
            ],
            'manifests' => [
                $package => [
                    'repository' => sprintf('github.com/%s', $repository),
                    'package' => $package,
                    'version' => $version,
                    'manifest' => $manifest,
                    'files' => $files,
                    'origin' => sprintf('%s:%s@github.com/%s:%s', $package, $version, $repository, $sourceBranch),
                    'not_installable' => false,
                    'is_contrib' => $contrib,
                ],
            ],
        ], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));
    }
}
